## js、css、img、是否阻塞文档的解析和渲染
1. js script的加载或者执行都会阻塞html解析、其他下载线程以及渲染线程;
2. css的加载和解析不会阻塞html的解析，但会阻塞渲染;
3. img的加载不会阻塞html的解析，但img加载后并不渲染，它需要等待Render Tree生成完后
	才和Render Tree一起渲染出来。未下载完的图片需等下载完后才渲染;
4. js css img 在一开始解析页面的时候就并行下载了，不是解析到对应的标签才下载。
## 原型链与原型链继承
（https://juejin.im/post/58f94c9bb123db411953691b）
1. instanceof  构造函数的显式原型对象在实例的隐式原型链上，则实例是该构造函数的实例。
2. 实例的constructor 指向实例的隐式原型对象的constructor属性指向的对象；
3. * 原型链继承 
        * 问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;
	    * 问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数.	
   * 借用构造函数  
        * 解决了原型链继承存在的两个问题，但是产生了新的问题，
	    * 问题1：方法都在构造函数中定义, 无法实现函数复用
	    * 问题2：超类型(如Father)中定义的方法,对子类型而言也是不可见的.
   * 组合继承 
        * 将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.
        * 既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性，不共享原型上的引用类型的属性
        * 问题1:组合继承其实调用了两次父类构造函数, 造成了不必要的消耗
   * 原型式继承
        * 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型链模式一样.
        * object.create() 接收两个参数:一个用作新对象原型的对象(可选的)，一个为新对象定义额外属性的对象
        * object.create()的第二个参数 以这种方式指定的任何属性都会覆盖原型对象上的同名属性.
   * 寄生式继承
        * 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.
   * 寄生组合式继承
        *  寄生组合式继承就是为了降低调用父类构造函数的开销而出现的 .
        * 没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法.
4. new 运算符
    * 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。var obj  = {};this = obj;obj.__proto__ = F.prototype;
    * 属性和方法被加入到 this 引用的对象中。F.call(obj);
    * 最后隐式的返回 this.如果构造函数最后返回的是this或是基本数据类型的数据，那么就返回新建的对象，如果返回值是一个引用类型，那么就返回这个
        引用类型
5. 判断一个函数是以构造函数调用还是以普通函数调用
    * function f(){
        if(this instanceof arguments.callee)
          console.log('此处作为构造函数被调用');
        else
          console.log('此处作为普通函数被调用');
      }
      f();//此处作为普通函数被调用
      new f();//此处作为构造函数被调用
## 只给div设置样式，使其水平垂直居中对齐
    <div style="text-align:center;line-height: 100px; background-color: red;width: 100px; height: 100px; position: absolute; top: calc(50% - 50px); left: calc(50% - 50px);">颜海镜</div>
    
## js 浏览器端的事件循环机制以及宏任务和微任务
（https://juejin.im/post/59e85eebf265da430d571f89）
（http://www.ruanyifeng.com/blog/2014/10/event-loop.html）
1. 任务队列分为宏任务队列和微任务队列，宏任务队列中的任务是每次循环执行一个，微任务队列中的微任务一次执行所有
    主代码块 > setImmediate > MessageChannel > setTimeout / setInterval 会被加入宏任务队列
    process.nextTick > Promise > MutationObserver  会被加入微任务队列
2. js 主线程执行代码，将代码放入执行栈，然后执行，出栈，当遇到异步任务，具有回调函数的代码，例如定时器，ajax，dom事件
    ，js引擎会将异步任务交给浏览器内核的相对应的处理模块进行处理，定时器，ajax和dom事件分别有不同的处理模块，此时js主线程
    同时在处理同步任务，当异步任务被响应模块处理完后，会将这些任务放到任务队列。 当js主线程的同步任务处理完毕，就会依次执行
    任务队列中的代码。
3. 具体的执行顺序呢， 先是js主代码块作为第一个宏任务执行，遇到setTimeout等异步任务，便将其放入宏任务队列，遇到promise等
    异步任务，便将其放入微任务队列。 然后js主线程的同步任务执行完，检查微任务队列有没有任务，有的话，一次全执行，
    然后在检查宏任务队列有没有任务，有的话就执行第一个，执行完在执行微任务队列中的任务，如此循环。
    
## js事件绑定有几种方式
1. 行内绑定 onclick= "alert(123)";
2. dom.onclick = function(){} 绑定多个事件会被覆盖掉
3. 事件监听的方式， dom.AddEventListener(事件名称不带on，回调函数,是否事件捕获时触发)；removeEventListener 不支持IE8及以下浏览器
    可以为某个事件绑定多个监听函数，先绑定先执行
4. 兼容IE7/8的attachEvent(事件名称带on，回调函数) detachEvent  可以为某个事件绑定多个监听函数，后绑定先执行
## mousemover mouseout mouseenter mouseleave  的区别
1. mouseover触发优先级高于mouseenter，mouseout触发优先级高于mouseleave，先触发over 和out
2. mouseover和mouseout支持事件冒泡， mouseenter和mouseleave不支持事件冒泡
3. mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
    mouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
    mouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
    mouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。
## http状态码
（http://tools.jb51.net/table/http_status_code）
1. http状态码分为5类，1**开头状态码的代表，信息，服务器收到请求，需要请求者继续执行操作
                     2**开头的状态码代表，成功，请求被服务器成功接收并处理
                     3**开头的状态码代表，重定向，需要进一步操作才能完成请求获得资源
                     4**开头的状态码代表，客户端错误，请求包含语法错误或者无法完成请求
                     5**开头的状态码代表，服务器端错误，服务器在处理请求的过程中发生了错误
2. 常见的状态码有 200-请求成功，301-重定向，资源（网页等）被永久转移到其他的url，404-请求的资源（网页等）不存在
                   500-服务器内部错误，304-未修改，所请求的资源未修改，服务器返回此状态码时不会返回任何资源，使用
                   客户端之前请求时缓存的资源，400-客户端请求语法错误，服务器无法理解
## 什么是同源策略及其限制内容
1. 同源策略是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS和CSRF等攻击，所谓的同源策略
    指的是协议、域名、端口号三者相同，即便两个不同的域名指向同一个ip地址，也非同源
2. 同源策略限制的内容有：
    * cookie、localStorage、indexDB等存储性内容无法获取
    * 无法获取dom节点
    * ajax请求发送后，返回的结果被浏览器拦截
3. 有三个标签允许跨域加载资源
    * img src="xxx"
    * link href="xxx"
    * script src="xxx"
## 对于跨域的理解
1. 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。
2. 如果是协议和端口造成的跨域问题“前台”是无能为力的。
3. 在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。
4. 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
5.你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到
    另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，
    所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。
    
## 跨域解决方案
跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
ajax 本身受制于同源策略，是不支持跨域请求的，但是可以通过jsonp 和cors 的方式实现ajax 的跨域请求
1. jsonp原理：利用 \<script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。
    JSONP请求一定需要对方的服务器做支持才可以
    * jsonp和ajax比较:都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，
    JSONP属于非同源策略（跨域请求）
    * jsonp优缺点： jsonp的优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问问题，缺点是仅支持get方法
        具有局限性，可能会遭受xss攻击；
    * jsonp实现流程: 定义一个处理函数，通过script的src以get传参的方式将函数名发送到请求数据的服务端，服务端
        监听这个请求，并将收到的函数名和请求的数据当作函数的参数一并返回，这样页面就得到了跨域的数据
2. cors
    * CORS 需要浏览器和后端同时支持，IE 8 和 9 需要通过 XDomainRequest 来实现。
    * 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
    * 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，
        如果设置通配符则表示所有网站都可以访问资源。
    * 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，
        分别为简单请求和复杂请求。请求的方式为get post head 并且contenttype 为text/plain multipart/form-data application/x-www-form-urlencoded
        三个中的一个，就是简单请求，除此之外都是复杂请求， 复杂请求在请求发送之前需要先发一个option方法，称为预检，用来获取服务端是否支持跨域 
3. postMessage
    * postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，
        通过postMessage和onMessage实现传送和接收数据
4. 使用websocket 进行跨域数据请求 
5. node中间件代理 nginx反向代理实现跨域数据请求，主要是通过同源策略不对服务器加以限制
6. window.name + iframe window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，
    并且可以支持非常长的 name 值（2MB）。
    实现： 想要在a.html获取不同域的c.html中的数据，先在a中加载外域的iframe c.html， 然后外域的iframe中有name属性存着数据，
    然后将 iframe的src 改为和a同源的b.html， 这样b就可以得到name属性的值了，然后b在将数据传给a；
7. location.hash + iframe
    实现a页面获取外域c页面中的值   a和b是同源的，a中的iframe 的src 是c， 给src加一个hash，c页面检测到hash变化后，
    c在页面内创建一个iframe src 是b, 改变的hash， 然后b得到改变后的hash， 然后将hash值放到传给a页面， 这样就得到数据了
8. document.domain + iframe
    该方式只能用于主域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
    只需要给页面添加 document.domain ='test.com' 表示主域名都相同就可以实现跨域。
    两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
    
## 浏览器的渲染过程
（https://github.com/ljianshu/Blog/issues/51）
1. 浏览器解析html/xhtml/svg，将其解析成dom树形结构；
2. 浏览器解析css，将其解析成css规则树，它和dom树的结构比较像；
3. 等javascript脚本加载后，通过DOM API和CSSOM API操作dom树和css规则树；
4. 解析完成后，浏览器引擎会根据DOM Tree和CSS 规则树来构造渲染树Rendering Tree；
5. 渲染树并不等同于DOM树，渲染树只包括要显示的节点和这些节点的样式信息
6. 计算各个节点在页面中的确切位置和大小，这又叫layout和reflow
7. 最后调用操作系统的Native GUI的api 将这些元素绘制在屏幕上
## 浏览器页面渲染注意的问题
1. 遇到script标签就停止渲染，执行js代码，因为浏览器有GUI线程和js引擎线程，为了防止渲染出现不可预期的结果，这两个
    线程是互斥的，所以，script 的加载和执行会阻塞渲染；
2. js还会阻塞dom的构建， HTML解析器遇到js，就会暂停dom构建，将控制权交给js引擎，js执行完毕，浏览器再从中断的地方恢复dom的构建
3. cssom的构建和dom的构建本来互不影响，但是一旦有js影响就变了，如果cssom还没构建完，这时遇到了js，需要执行js，但是js执行
    必须等cssom构建完毕才能执行，所以就变成先等csoom构建完毕，在执行js,最后恢复dom构建。css在js的影响下间接的阻塞了
    dom的构建。
4. css也会阻塞渲染，因为只有dom树和css规则树都创建完毕，才会进入下一个阶段，生成rendering tree
## 为什么操作dom慢
1. 浏览器内核是支撑浏览器运行的核心，分为两个部分，js引擎和渲染引擎；
2. Dom属于渲染引擎部分，但是js属于js引擎的东西，当js操作dom的时候，本质上是渲染引擎和js引擎进行了跨界交流
    ，这种跨界交流多了就很消耗性能， 所以操作dom很慢  
3. 操作dom会触发回流和重绘，很消耗性能，所以慢
## 重排（回流）和重绘
1. 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色、背景色）时，
    浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式。
2. 重排：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，
    浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。
3. 常见的引起重排的属性和方法
   * 添加或删除可见的dom元素
   * 元素的尺寸发生改变-边距，填充，边框，宽度和高度
   * 内容发生变化，比如用户在input中输入文字
   * 浏览器窗口尺寸发生变化
   * 计算offsetWidth offsetHeight属性
   * 设置style属性的值
4. 常见的引起重绘的属性
    * color background-color border-radius background的一系列属性
5. 如何减少重排和重绘
    * 使用 transform 替代 top
    * 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流
    * 不要把节点的属性值放在一个循环里当成循环里的变量。
    * 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
    * 动画实现的速度的选择，动画速度越快，重排次数越多，也可以选择使用 requestAnimationFrame
    * CSS 选择符从右往左匹配查找，避免节点层级过多
    * 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。
        比如对于 video 标签来说，浏览器会自动将该节点变为图层
    * 将要创建的多个dom节点放到domFragment中，再放到页面中
    * 将要修改的样式组成一个类
    
    
## 浏览器存储
1. cookie
    * HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，服务器可以设置或读取Cookies中包含信息，
        来维护用户跟服务器会话中的状态。
    * cookie附着在http请求中，在浏览器和服务器之间飞来飞去，它可以携带用户信息，当服务器检查cookie时，便可以获得到客户端的状态
    * Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储
    * cookie 是键值对的形式
    * cookie的应用场景：记住密码下次自动给登录；购物车功能；记录用户浏览数据，进行商品以及广告的推送
    * cookie的两种生成方式：在响应头的set-cookie中指定要存储的值；js可以通过document.cookie 读写cookie
    * cookie的缺陷：
        * cookie不够大，每条cookie大小限制在4K左右，并且浏览器对cookie的条数还有限制
        * 过大的cookie会造成巨大的性能浪费，因为同一域名下的所有请求都会携带cookie，即使不需要cookie信息
        * 在http请求中cookie是明文传递的，所以存在安全性问题。
    * cookie的value属性多数保存用户的信息，应该将值加密，不能明文传递
    * 设置http-only 属性后，不能通过js访问cookie, 减少xss攻击
    * 设置secure 属性后，只有https协议的请求，才会携带cookie
    * 设置same-site 属性后，浏览器不能再跨域请求中携带cookie,减少csrf攻击
    * 在设置的过期时间之前有效
2. Localstorage 
    * localstorage保存的数据长期存在，下次访问网页的时候，可以直接读取之前存储的值
    * 总大小为5M左右
    * 仅在客户端使用，不与服务器进行通讯
    * 接口封装较好
    * 存储数据 localstorage.setItem(name.value); 获取数据 localstorage.getItme(name)
    * 使用场景： 存储一些内容稳定的资源，比如图片等
3. sessionStorage
    * 会话级别的浏览器存储，会话结束（tab标签页关闭），存储的信息便销毁
    * 大小为5M左右
    * 仅在客户端使用， 不与服务器进行通讯
    * 接口封装较好
    * 使用场景： 可以用sessionStorage维护一些表单信息，当前页面刷新后，之前的表单信息不丢失；存储生命周期和sessionStorage相同的信息
4. sessionStorage、localstorage、cookie之间的区别和联系
    * 共同点：他们三个都是保存在浏览器端，且都遵循同源策略
    * 不同点：生命周期和作用域不同
        * localstorage 只要在属于同源的页面，就可以读取和修改localstorage保存的信息
        * sessionstorage 不仅要求页面同源，还要求页面属于同一个tab标签页
        * cookie 只要在属于同源的页面，就可以读取和修改cookie保存的信息
5. indexedDB
    * indexedDB用于客户端存储大量的结构化数据（包括文件和blobs）
    * 是一种非关系型数据库
    * indexedDB是以键值对的形式进行存储
    * indexedDB的读取操作是异步的，与webStorage不同，异步设计是为了防止大量数据的读写，拖慢网页的表现。
    * 支持事务，有一步失败，整个事务就取消，数据库回滚到之前的状态，不会会改变部分数据
    * 受同源限制
    * 存储空间大，并且可以存储二进制数据
    * 除非主动清理，否则一直存在
    
    
## 浏览器的缓存机制
1. 根据缓存的位置可以将缓存分为四种
    * Service Worker Service Worker是运行在浏览器内部的独立线程，用于缓存数据，使用Service Worker必须使用https协议
        因为Service Worker涉及到请求拦截，所以必须使用https协议来保证安全
        * 首先注册Service Worker，然后监听install事件，就可以缓存文件了，下次通过拦截用户请求的方式，查询是否存在缓存
            存在的话就是用缓存，不存在的话就调用fetch函数去获取数据。根据涉设置的缓存的优先级去获取，不管最后是在哪
            获取到的资源，浏览器都显示是从service worker 中获取的的内容
    * Memory Cache 内存中的缓存主要是包含从当前页面抓取下来的样式、脚本、图片等，内存缓存的特点是读取高效，但是持续性
        很短，一旦关闭tab标签页，内存中的缓存也就释放了，并且内存中能缓存的数据量比较小
        * 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，
            还可能会对Content-Type，CORS等其他特征做校验。
    * Disk Cache 硬盘缓存相对于内存缓存，读取速度慢，但是存储的数据量大，并且缓存的持久性更长 ，硬盘缓存会根据http Header
        中的字段判断哪些资源需要进行缓存，哪些资源可以不请求直接用，哪些资源过期了需要重新请求，浏览器的绝大部分
        缓存都来自Disk Cache
        * 对于大文件，大概率是不会缓存到内存，反之优先
        * 当前系统内存使用率高的话，文件优先存储到硬盘
    * push Cache Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）
        中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。
2. 浏览器中数据缓存的过程
    * 第一次请求时，将请求结果和缓存标志存到浏览器缓存中；
    * 之后请求时，先在浏览器缓存中查看是否有请求的结果，如果有的话，再根据缓存策略，判断是直接使用还是重新发起请求
        如果没有缓存结果，那么就发起请求，然后将返回的请求结果和缓存标志存到浏览器的缓存中
3. 浏览器的缓存策略
    * 强缓存 不会向服务器发送请求，直接从缓存中读取资源，强缓存可以通过设置两种http header 来实现 
        * Expires Expires是http1.0的产物，用来指定资源到期时间，资源到期之前，无需发起请求，  直接使用缓存中的资源
            若资源到期，需要再次发起请求获取最新资源，Expires会受限于本地时间，如果修改了本地时间，可能造成缓存失效
        * Cache-Control Cache-Control是http 1.1 中的重要规则，主要用于控制网页缓存，如果再Cache-Control设定的到期时间内
            再次请求该资源，无需发起请求，直接使用缓存
            * Cache-Control 有一些属性可以设置，public 表示浏览器和代理服务器都可以缓存资源，private表示只有浏览器可以缓存资源
                max-age表示浏览器缓存多长时间后资源就会过期，需要重新请求，s-max-age表示代理服务器缓存多长时间后，资源就会
                过期，需要重新请求。s-max-age的优先级高于max-age, 会夫覆盖掉max-age, no-store表示不缓存任何资源，no-cache表示
                客户端缓存资源，下次请求时是否使用缓存需要经过协商缓存来决定，max-stale，表示缓存的资源过期多久还可以使用，min-fresh
                表示，客户端希望使用多少时间内请求来的数据，如果过了这个时间，数据就不新鲜了，需要重新请求
        * Expires和Cache-Control两者对比：Expires是http1.0的产物，Cache-Control 是http1.1的产物，两者同时存在的话
            Cache-Control的优先级比Expires高，在某些不支持http1.1的环境下，Expires就会起作用，现在Expires更多的是
            一种兼容性写法
    * 协商缓存 协商缓存就是强缓存失效后，浏览器携带缓存标志向服务器发起请求，由服务器根据缓存标志来决定是否使用缓存。协商
        缓存生效返回304和not modify ，协商缓存失效返回200和请求结果，协商缓存可以通过设置两种 http Header 实现：Last-Modified 和Etag
        * Last-Modified 和 If-Modified-Since
         浏览器第一次请求资源时，服务器返回资源，并且在响应头中添加Last-Modified, 浏览器下次请求这个资源的时候，发现有Last-Modified
         所有就在请求头中添加If-Modified-Since，值就是之前得到的Last-Modified的值，服务器拿到If-Modified-Since的值和资源的最后修改时间
         做对比，如果相同则返回空资源和304，如果改变了，那么返回200和最新的资源
            * Last-Modified的一些弊端  当本地打开缓存文件时，即使没有修改文件，文件的Last-Modified的值也会改变，这就导致
                服务器不能命中缓存，重新发送了一次相同的资源；Last-Modified是以秒计时的，如果以极短的时间修改了文件，Last-Modified的值
                并没有改变，导致命中了缓存，使用了不是最新的资源
         * ETag和If-None-Match
               ETag和If-None-Match 的工作方式和Last-Modified 和 If-Modified-Since是类似的，不同的是，Last-Modified 和 If-Modified-Since
               是根据文件最后的修改时间来判断是不是用缓存，而ETag和If-None-Match是根据文件有没有真实的改变，来判断
               只要文件发生改变，那么ETag的值就会发生改变
         * 这两者之间的对比:服务器校验优先考虑ETag,ETag的性能要比Last-Modified差一些，因为Last-Modified只需要记录最后的
            修改时间，而ETag需要服务器根据算法生成一个hash值
4. 浏览器的缓存机制
    * 强缓存优先于协商缓存，如果强缓存生效，则直接使用缓存，如果强缓存不生效，则进行协商缓存，然后由服务器决定是否使用缓存
5. 如果什么缓存策略都没设置，那么浏览器会怎么处理？
    * 通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。
6. 该如何使用缓存策略
    * 对于频繁变动的资源，强制缓存中Cache-control 要设置为no-cache，使浏览器每次都请求服务器，然后根据协商缓存的
        设置，确定是否使用缓存，虽然不能减少请求次数，但是能减少响应资源的数量
    * 不常变化的资源，强制缓存中Cache-control 设置一个非常大的值， 每次请求这个资源，就直接在缓存中取；为了解决不常
        变化的资源更新了的问题，需要给资源文件的名称增加hash值或版本号等动态字符
7. 用户行为对浏览器的影响
    * 打开网页，地址栏输入网址，查找disk cache中是否由请求的资源，没有的话就进行网络请求
    * 普通刷新（f5），因为tab并没有关闭，所有memory cache 是存在的，先在内存缓存中，然后再在硬盘内存中查找，没有就请求
    * 强制清缓存刷新（ctrl+f5）浏览器不使用缓存，直接向服务器请求最新的资源，服务器返回200和最新的资源
    
## 从url输入到页面展现到底发生了什么
1. 总体来说分为以下几个过程：
    * DNS域名解析:将地址栏中输入的域名解析为对应的IP地址
        * DNS解析的过程：浏览器如何通过域名去查询域名所对应的IP地址呢？ 首先查找浏览器缓存，浏览器会按照一定频率缓存DNS记录
            如果浏览器缓存中没有，然后再去查找操作系统缓存，再去查找路由缓存，如果都没有就去isp的DNS服务器中查找，如果还是没有
            就去根服务器进行递归查找；
    * TCP连接， 三次握手的过程，当DNS服务器解析到了域名对应的IP地址后，浏览器在向这个ip地址对应的服务器发送http请求之前
            需要先和服务器进行三次握手（为了防止已经失效的连接请求报文突然发送到服务端而产生错误），三次握手用以同步客户端和服务端
            的序列号和确认号，并交换TCP窗口信息大小。
            第一次 客户端向服务端发送连接请求报文段，该报文段包括自身的数据通讯初始序号，请求发送后，客户端便进入SYN-SENT状态 (syn 是同步序列号)
            第二次 服务端接收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始讯号，发送完后，服务端进入
                   SYN-RECEIVED状态
            第三次 客户端接收到连接同意的应答后，还要向服务端发送一个确认报文，客户端发完确认报文后，进入ESTABLISHED状态，服务端接收到这个确认报文段
                   后也进入ESTABLISHED状态，此时连接建立成功
    * 发送http请求
        http请求报文由请求行、请求头、请求体三部分组成：
        *  请求行包括请求方法，URL，协议版本
        * 请求头包含请求的附件信息
        * 请求体包含要发送刚给服务器的数据信息
    * 服务器处理请求，并返回响应报文
        响应报文由响应行、响应头、响应体三部分组成：
        * 响应行包括 协议版本、状态码、状态码描述
        * 响应头包含响应报文的附件信息，由键值对组成
        * 响应体包含响应要返回的数据，并不是所有的响应报文都有响应数据（命中缓存）
    * 浏览器解析并渲染页面
    * 断开连接：tcp四次挥手
        第一次挥手 客户端的请求发送完毕，则客户端向服务端发送连接释放请求；
        第二次挥手 服务端收到连接释放请求后，告诉应用层释放TCP连接，此时客户端到服务端的连接已经释放，不再接收客户端发的数据，因为TCP是双向的，
                  所以服务端仍旧可以发数据给客户端
        第三次挥手 服务端此时如果还有没发送完的数据，会继续发送数据，发送完毕后，向客户端发送连接释放请求；
        第四次挥手 客户端收到释放连接请求后，向服务端发送确认应答，此时客户端进入time-wait状态，此状态会持续2MSL(如果报文段在网络中呆的时间超过2MSL就会被抛弃)
                若该时间段内，没有服务端的重发请求，客户端就进入CLOSED状态，服务端接收到确认应答后，也进如CLOSED状态
        
## js数据类型的检测
1. typeof typeof 返回的是字符串类型的小写字母， typeof无法检测null , array ,Date ,RegExp,都返回object
2. instanceof 判断一个实例是否属于某个类型； 原理是，某个类型（构造函数）的显示原型对象是否在这个实例的隐式原型链上，如果在返回true
    * 对于基本数据类型来说，字面量方式创建出来的结果和用构造函数方式创建出来的结果是不一样的 console.log(1 instanceof Number)//falseconsole.log(new Number(1) instanceof Number)//true
    * 只要某个构造函数的显示原型对象在实例的隐式原型链上，那么结果就是true,但是实例并不一定是这个类型
    * 不能检测null和undefined ,他们属于Null和Undefined类，但是浏览器不允许我们访问这两个类， 所以无法判断
3. constructor constructor和instanceof 非常相似，但是constructor 还可以检测基本数据类型
    * 不能检测null和undefined 
    * constructor 不稳定，如果把类型的原型重写，就会改变之前的constructor， 导致类型判断出错
4. Object.prototype.toString.call();
    * 对于Number、String，Boolean，Array，RegExp、Date、Function原型上的toString方法都是把当前的
        数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）
    * Object上的toString它的作用是返回当前方法执行的主体（方法中的this）所属类的详细信息即"[object Object]";
    
## js 中的六种错误类型
1. SyntaxError：语法错误
2. Uncaught ReferenceError：引用错误
3. RangeError：范围错误
4. TypeError类型错误
5. URIError，URL错误
6. EvalError eval()函数执行错误
## js 数据类型转换
## 细说数组常用的遍历方法
## 赋值操作，浅拷贝，深拷贝
1. 赋值操作、浅拷贝、深拷贝之间的区别
    *  赋值操作 赋值操作完成的两个对象， 指向同一个对象，这样的话，修改复制后对象的基本数据类型的属性和引用类型的属性，原始对象都会发生改变
    * 浅拷贝 拷贝前后的两个对象， 并不指向同一个对象，新对象是对老对向的一级拷贝，基本数据类型的属性则直接拷贝，引用类型的属性值，则拷贝引用类型
        的地址值， 这样的话，在新的对象中改变基本数据类型的值，老对象不会发生改变，改变引用类型的属性值，老对象的属性值也会发生改变
    * 深拷贝 深拷贝前后的两个对象，不指向同一个对象， 并且新对象是完完全全的新对象，引用类型不是拷贝的地址值，而是重新创建了一个对象，
        这样新老对象改变值都互不影响
    * 浅拷贝的方法
        * Object.assign(targetObj,resourceObj),可以将resourceObj自身的可枚举属性拷贝给targetObj,是浅拷贝， 但是当Object只有一层的时候，
            是深拷贝
        * 数组的concat 和 slice 方法 Array.prototype.concat()  [].concat() 方法可以实现浅拷贝
    * 深拷贝的方法
        * JSON.parse(JSON.stringify()) 这种方式虽然可以实现数组或对象的深拷贝，但是无法处理函数（函数会被转换成null）
        * 手写递归方法，实现深拷贝
        * 使用jquery 的 $.extend(true,[],array)  
    * 解决深拷贝对象互相引用的问题： 使用WeakMap ，设置克隆函数的第二个参数，一个WeakMap实例，在克隆函数最前面，判断，WeakMap里面有没有这个对象，有的话，就直接return, 遍历原对象的属性
        拷贝到新对象之前，先将这个对象加入到WeakMap中，key和value的值都是这个对象，然后递归，递归的时候，传入这个WeakMap实例
## 深入浅出js闭包
## js中的this
## 原型与原型链
1. 什么是原型，为什么又原型
    * 通过构造函数创建实例的时候，如果创建1W个实例，那么构造函数中的方法可能就会被创建1w次，但是这都是相同的代码，重复创建浪费了内存，
        在js中，每个函数数据类型（普通函数和构造函数）都都包含一个prototype属性，这个属性指向一个对象，这个对象就是函数的原型对象，我
        们可以将同一个类的所有实例的共有的方法定义在构造函数的原型对象上，这样所有的实例都拥有了这个方法，并且，只需要定义一次。原型
        对象的constructor属性指向构造函数，原型是所有实例的一个公共区域；
    * 原型链  什么是原型链，当访问对象的某个属性时，会首先在对象自身上查找这个属性，如果在对象身上没有查找到这个属性，就去对象的隐式原型
        属性对应的对象身上查找，如果还没有找到就取隐式原型对象的隐式原型属性对应的对象身上查找，一直找到Object对象的原型对象，这样就形成了一条链式
        结构，我们称这个链式结构为原型链，如果最后没有找到返回undefined
## DOM事件机制
## js常见的6中继承方式
1. 原型链继承
    * 原型链继承的关键在于子类型的原型是父类型的一个实例对象
    * 这样子类实例可以通过隐式原型属性访问到构造函数的显示原型对象，也就是父类的实例，这样就可以访问到父类实例上的私有方法，再通过父类
        实例的隐式原型属性，可以访问到父类原型上的方法，于是做到了将父类的私有、公有方法和属性都当作子类实例的公有属性和方法
    * 存在的问题，如果父类中有引用类型的数据，某个子类实例操作了这个引用类型的实例，那么其他子类访问该属性的时候，也会受到影响
        此外，在子类的原型上添加方法或重写父类的方法一定要写到替换原型之后
    * 特点：易于实现，父类的私有属性和原型上的属性和方法都可以访问到
    * 缺点：无法实现多继承，原型对象的所有属性被所有实例共享，创建子类实例时，无法向父类构造函数传参，要想给子类新增属性和方法，必须在修改
        子类的原型对象之后
2. 借用构造函数继承
    * 借用构造函数继承的关键在于：在子类的构造函数中，通过call()调用父类的构造函数
    * 特点：解决了原型链继承中，子类实例共享父类引用类型属性的值，创建子类实例时，可以向父类构造函数传参，可以实现多继承（call多个父类对象）
    * 缺点： 实例不是父类的实例，只是子类的实例，只能继承父类实例的属性和方法，不能继承父类原型对象上的属性和方法，无法实现函数复用，每个子类
        都父类实例上方法的副本，影响性能
3. 原型链+借用构造函数 组合继承
    * 关键：通过调用父类的构造函数，继承父类的属性和方法保留传参的优点，然后将父类实例作为子类原型，实现函数复用
    * 优点：可以继承父类实例的属性和方法，也可以继承原型上的属性和方法，不存在引用属性共享的问题，创建子类实例时可以给父类构造函数传参，函数可以复用
    * 缺点：调用了两次父类的构造函数，生成了两份实例
4. 组合继承优化1
    * 子类原型和父类的原型指向同一个对象，都指向父类的原型对象，这样子类即可以继承父类的私有属性和方法，也可以继承到父类原型上的属性和方法
        这样避免了调用两次父类的构造函数
    * 缺点：无法辨别实例对象是子类构造出来的还是父类构造出来的，子类和父类的原型对象的constuctor指向的是同一个构造函数
5. 组合继承优化2
    * 通过Object.create()方法，创建一个以父类的原型对象为原型对象的对象，将这个对象设为子类的原型对象，并更改子类原型对象的constructor
        指向，这时目前来说最完美的继承方法
6. 通过class 继承
    * 通过extends关键字实现继承，通过super()调用父类的构造函数
## js 中的垃圾回收和内存泄漏
1. js具有自动垃圾回收机制， 垃圾回收机制有两种方法:标记清除，引用计数，引用计数存在循环引用的问题，所以不太常用，老版本的IE使用的引用计数
2. 标记清除
    * 当变量进入执行环境的时候，变量就会被标记上“进入环境”，标记为“进入环境”的变量是不会被垃圾回收器回收的，当变量离开了执行环境，变量就会被
        标记上“离开环境”，在垃圾回收器下一次运行的时候，就会把这些被标记为“离开环境”的变量回收，释放他们占用的内存
3. 引用计数
    * 垃圾回收器会回收那些不在被引用的变量，因为这些变量没人用了，别人也用不到它了；一个变量被引用几次，垃圾回收器就会将这个变量标记为几，当引用
        增加的时候，计数就增加，引用减少的时候，计数就响应的减少，直到变量的引用计数为0的时候，下次垃圾回收器运行就会把这个变量回收，释放这个
        变量占用的内存
    * 引用计数存在的问题，循环引用问题，这样，计数不为0，但变量不在被其他地方引用，还无法回收他们
4. 造成内存泄漏的情况
    * 意外的全局变量
    * 被遗忘的定时器以及dom事件回调函数
    * 闭包
    * 没有清理的DOM元素的引用
## 常见的web前端攻击
1. XSS 跨站脚本攻击
    xss 的原理是攻击者往web页面里插入恶意可执行的网页脚本代码，当用户浏览该页面的时候，嵌入其中的恶意脚本代码就会执行
    ，从而达到窃取用户信息或者其他侵犯用户安全隐私的目的。xss的攻击方式分为两种：
    * 非持久性xss（反射性xss）
        一般是给别人发送带有恶意代码参数的URL,当url被打开的时候，恶意代码就会被执行，反射型xss的漏洞攻击的几个特点：
        * 即时性，不经过服务器存储，直接通过get和post请求就能完成一次攻击，拿到用户信息
        * 攻击者需要诱骗用户点击，必须通过用户点击链接才能发起
        * 反馈率低，较难发现和响应修复
        * 盗取用户的敏感信息
    * 反射型xss的防御手段：
        * web页面渲染的所有内容和数据都来自服务器端
        * 尽量不要直接从URL，document.forms，document,referer,等dom api中获取数据进行渲染
        * 尽量不要使用eval,new Function(),document.write(),innerHtml等可执行字符串的方法
        * 前端渲染的时候，对任何字段都要做escape转义编码
    * 持久性XSS（存储型xss）
        存储型的xss一般存在于form表单提交等交互功能，比如文章留言，提交文本信息等，黑客利用xss漏洞，将恶意代码经正常功能
        发送到服务端，并存储在数据库，当前端页面获取到后端从数据库得到的注入的恶意代码时，恰好将其渲染执行。注入页面的方式
        和反射型xss类似。存储型xss攻击成功需要满足以下几个条件：
        * post请求提交表单后，后端没有转义直接入库
        * 后端从数据库取出数据后，没有做转移直接发送给前端
        * 前端拿到后端发送来的数据没有转移直接渲染成dom
    * 持久性xss有以下几个特点
        * 持久性，植入在数据库中
        * 盗取用户敏感私密信息
        * 危害面广
    * xss的防御手段
        * csp（内容安全策略）
            csp本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行，我们只需配置规则，如何拦截由浏览器自己实现
            可以通过两种方式开启csp， 1.设置http Header中的Content-Security-Policy,2.设置meta标签 http-equiv='Content-Security-Policy
            '
        * 转义字符  对用户输入输出的内容进行转义，转义引号，尖括号，斜杠等
        * 设置Cookie 的HttpOnly属性 web应用程序在设置cookie的时候，将其属性设置为HttpOnly，避免cookie被攻击者的恶意js代码在浏览器端获取
   
2. CSRF（跨站点请求伪造）
    * 完成CSRF攻击必须要有三个条件：1用户已经登录了A站点，并在本地记录了cookie，2在用户没有登出站点A的情况下
         （即cookie还生效的情况下），访问了攻击者提供的引诱危险站点B（B站点要求访问A站点）3站点A没有做什么CSRF防御
    * 如何防御CSRF攻击
        * get请求不对数据进行修改
        * 不让第三方网站访问cookie
        * 阻止第三方网站的请求接口
        * 请求时附带验证信息，比如验证码或者token 
        * 可以设置cookie的same-site属性，跨域请求不允许携带cookie
        * HTTP refer 会保存请求的来源信息，服务器通过来源信息判断是否csrf攻击，然后决定处不处理请求。Https跳转到http，不会发送refer
        * 当用户第一次登录网站时，会将用户名和密码发送给服务端进行验证，验证通过后，服务端生成一个token 发送给前端，以后前端发送请求
            不需要携带用户名和密码等验证信息，只需携带token即可，服务端通过比较前端传来的token和当前域下cookie中保存的token,如果一致则
            处理前端发来的请求，如果不一致则认为时csrf攻击，不处理请求
        * 如果所有操作都使用验证，则会极大降低用户的使用体验，所有验证码只在关键业务时使用
3. 点击劫持
    点击劫持是一种视觉欺骗手段，攻击者将需要攻击的网站以iframe的方式嵌入在自己的网页中，并将iframe设置为透明，在页面中
    透出一个按钮，诱导用户点击 
    * 用户登录了网站A，被攻击者诱惑打开了第三方网站，而第三方网站通过iframe嵌入了A网页，用户在第三方网站点击了被装饰了的
        按钮，实际上时点击了A网站的按钮
    * 点击劫持的防御手段
        * X-FRAME-OPTIONS   X-FRAME-OPTIONS是一个http响应头，该响应头有三个值可以选择，DENY，页面不允许通过iframe加载
            SAMEORIGIN,表示页面可以在相同域名下通过iframe来展现，ALLOW-FROM 表示页面可以在指定来源的iframe中展示
        * javascript 防御， 假如 self 和top 相等，那么就将页面的style 标签删除，如果不相等， 那么就top.location = self.location
4. URL跳转漏洞  借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题。
    * 如何防御URL跳转漏洞   
        * 加入有效性验证Token
        * 验证Http referer
5. SQL注入
    * SQL注入的必备条件
        * 可以控制输入的数据
        * 服务器要执行的代码拼接了控制的数据
        * 本质：数据和代码未分离，数据被当作代码来执行
    * 如何防御SQL注入
        * 严格限制WEB应用的数据库的操作权限
        * 后端代码检查输入的数据是否符合预期， 严格控制变量的类型
        * 对进入数据库的特殊字符进行转义处理（< > . * &^）
        * 所有的数据库查询语句建议使用数据库提供的参数化查询接口
6. os命令注入攻击
    os命令注入攻击和sql注入攻击类似，区别是sql注入攻击针对的是数据库，os命令注入攻击针对的是操作系统
    * 后端对前端提交的内容进行规则限制（比如正则表达式）
    * 在调用系统命令前对所有传入的参数进行命令行参数的转义过滤
    * 不要直接拼接命令语句，借助一些工具做拼接、转义预处理
          
 
## 关于http协议，你需要知道这些
1. http 的特点
    * 简单快速： 客户向服务器请求服务时，只需传送请求方法和路径，常用的请求方法包括：GET POST PUT DELETE HEAD
    * 灵活： http允许传输任意类型的数据对象
    * 无连接： 无连接的含义是每次连接只处理一个请求。服务器处理完请求，并收到客户的应答，就断开连接。
    * 无状态： http协议自身不对请求和响应之间的通讯状态进行保存，即任何两次请求之间没有任何依赖关系。这是为了更快的处理大量事务。
2. http 报文
    * http报文包括请求报文和响应报文两种，请求报文由请求行、请求头、空行、请求体四部分组成，响应报文由响应行、响应头、空行、响应体四部分组成
    * 请求行包括 请求的类型，要访问的资源，以及协议的版本号；响应行包括 协议版本，状态码，状态码描述
    * 请求头由键值对组成，每行一对，请求头部通知服务器有关客户端环境和请求正文的有用信息，响应头包括响应报文的附加信息
    * 最后一个请求头之后是一个空行，这个空行非常重要，它表示请求头已经结束，接下来是请求正文
    * 请求体，可以承载多个请求参数的数据
3. http 请求方法
    * GET 请求资源，请求指定的页面信息，并返回实体主体
    * POST 传输资源，向指定资源提交数据进行处理（提交表单或上传文件），数据包含在请求体中
    * PUT 更新资源，客户端向服务端传送数据替代指定的文档的内容
    * DELETE 删除资源，请求服务器删除指定页面
    * HEAD 获取报文首部，类似于get请求，但是返回的响应中没有具体的内容，用于获取报头
4. GET请求和POST请求的区别
    * GET请求在浏览器回退的时候是无害的，而POST请求会再次提交请求
    * GET请求得到的数据会被浏览器主动缓存，而POST请求不会，除非手动设置
    * GET请求参数会被完整的保留在浏览器历史记录中，而POST中的参数不会被保留
    * GET请求在url中传送的参数是由长度限制的，但是POST没有
    * GET请求通过URL传递参数，POST请求将参数放在请求体中
5. 持久连接
    * http协议的初始版本中，每进行一次http通信，就要断开一次tcp连接，每次请求都会造成无谓的TCP连接和断开，增加通信量的开销
    * 为了解决TCP连接的问题，http1.1提出了持久连接Connection, keep-alive，只要任一端没有明确提出断开连接，则保持tcp连接状态
        http1.1中默认开启持久连接，这样一个TCP连接可以处理多个http请求
6. 管线化
    * 之前的http请求都是 请求1》响应1》请求2》响应2.。。。
    * 现在的http连接 请求1》请求2》响应1》响应2.。。。
    * 通俗的讲就是一次性将所有的http请求打包发送给服务器端，服务端按顺序处理请求，按顺序响应
7. http1.0 ,http1.1, http2.0 的区别
    * http1.0 是简单快速、灵活、无状态、无连接的协议，无法复用tcp 连接，队头阻塞，http1.0规定下一个请求必须在前一个请求的响应到达之后才能发送，假设
        前一个请求的响应迟迟不归，那么后面的请求就无法发送，就会产生阻塞
    * http1.1 继承了1.0版本的简单的特点之外，还克服了诸多1.0版本上的性能问题
        首先是长连接：增加了connection字段，通过设置keep-alive可以保持tcp连接不断开，可以使用此连接发送多个http请求， 
        如果客户端想关闭http连接，可以在请求头中携带Connection：false 来告知服务器关闭
        管道化：请求能够并行传输，但是响应还是按顺序响应，以便客户端能够区分每次请求的响应内容，必须等第一个响应发送后才发送后续的响应内容
            可以同时打开多个TCP连接， 来时实现真正的并行请求
        还增加了缓存处理，新的字段如Cache-Control, 支持断点传输 字段Content-Range，增加了host 字段（一个服务器可以创建多个web站点）
    * http2.0 
        首先是:二进制分帧，通过在应用层和传输层之间增加一个二进制分帧层，突破了1.1版本的性能限制，改进传输性能
        多路复用：可以做到一个TCP连接并发处理多个请求，并且并发请求的数量比1.1版本大了很多
        header 头部压缩：在http1.x中头部的数据都是以纯文本的形式发送，2.0版本使用encoder对头部信息进行压缩，这样数据体积小了，在网上传输的速率就会更快
            通讯双方各自缓存一份header fields表；
        服务端推送： 服务端不仅可以对客户端发来的请求进行响应， 也可以主动向客户端推送资源，而无需客户端明确的请求
8. http 的局限性
    * http 是半双工协议，在同一时刻，数据只能单向流动
    * 服务器不能主动向浏览器推送数据，这就会导致一些高级的场景无法实现，比如聊天室就无法实现 
        
## ajax 原理
1. ajax 就是异步请求数据，在不重新刷新页面的情况下，异步从后台获取数据，并渲染到页面上，提升了用户的体验。正常表单的方式提交请求
    会刷新页面，但是ajax 请求的方式，可以在无刷新页面的情况下得到后台传来的数据，并渲染
2. XMLHttpRequest 对象的readState 属性，一共有5个值：
    * 0 ：尚未初始化---尚未调用open（）方法
    * 1 ：启动，已经调用了open()方法，还没调用send()方法
    * 2 : 发送，已经调用了send()方法，但是还没有接收到响应
    * 3 ：接收，已经接收到了部分响应数据
    * 4 ：完成，已经接收到了全部的响应数据，可以在客户端使用数据了
3. 手写一个原生ajax
    var xhr = null;
    if(window.XMLHttpRequest){xhr = new XMLHttpRequest()}else{xhr = new ActiveXObject(Microsoft XMLHTTP)}
    xhr.open(method,url,async)
    xhr.setRequestHeader(ContentType,application/x-www-form-urlencoded)//post请求必须设置请求头
    xhr.send（name=gws&age=18）
    xhr.onreadstatechange = function(){
        if(xhr.readState = 4 && xhr.status = 200){
            //成功的回调
        }
    }
    
## web实时推送技术的总结
1. 轮询（polling）轮询是客户端和服务器之间一直进行连接，每隔一段时间就询问一次
    * 优点:实现简单，无需做过多的更改
    * 缺点：轮询的时间间隔过长，将导致用户不能接收到最新的数据；轮询的时间过短，会导致查询请求过多，增加服务器的负担
2. 长轮询 长轮询是客户端向服务器发送查询请求，如果有最新的数据，就将数据返回， 如果没有最新的数据，就将请求hold在服务器，直到有最新的数据
     或者直到请求超时，然后返回，再次进行新一轮的请求。
     * 优点:相对于轮询做了优化，有较好的时效性，减少了网络请求的次数
     * 缺点：服务端保持连接会消耗资源，服务器没有返回有效数据时，程序超时
3. iframe流 在页面中插入一个隐藏的iframe,利用src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据，来实时更新页面   
    * 优点：消息能够实时到达， 浏览器兼容性好
    * 缺点：服务器维护一个长连接会增加开销，IE、chrome、firefox 会显示加载没有完成，图标会不停进行旋转
4. websocket    
    websocket 的特点
    * websocket 是全双工协议，支持双向通信，实时性更强
    * 可以发送文本，也可以发送二进制数据
    * 减少了连接次数，只要建立起websocket连接，客户端和服务端就一直保持连接，除非手动断开连接，和http相比，不但连接时的总开销减少
        websocket的首部信息也很少，通信量也减少了。
5. websocket 断线重连
## 深入理解BFC
1. BFC是一个容器，用于管理块级元素，它是一个独立的渲染区域，区内的元素的布局不影响外部的元素，外部元素的布局也不会影响内部元素
2. 如何创建（触发）BFC
    * float 设置为left|right
    * overflow 设置为hidden|auto|scroll
    * display 设置为table-cell|table-caption|inline-block|inline-flex|flex
    * position 设置为absolute | fixed
    * 根元素本身就是一个BFC容器
3. BFC布局规则
    * 内部的box会在垂直方向上一个接一个的排列（即块级元素独占一行）
    * BFC的区域不会与设置了浮动的box 重叠（利用这一点可以是实现自适应两列布局）
    * 属于同一个BFC的两个相邻box会发生margin重叠（margin重叠有三个条件：同属于一个BFC，块级元素，相邻）
    * 计算BFC的高度时，浮动的元素也参与计算
    * BFC是页面上的一个独立的容器，容器内部子元素的布局不会影响外面的元素，反之也是如此
4. BFC有哪些特性
    * BFC会阻止垂直外边距折叠  相邻兄弟元素margin发生重叠，父子元素margin发生重叠
    * BFC不会重叠浮动元素
    * BFC可以包含浮动元素，所以可以通过触发BFC来是实现清除浮动的效果
## ES6 核心内容
1. let const 解决的问题
    * 不再需要立即执行函数，立即执行函数的作用就是形成新的函数作用域，保存变量的值
    * 循环体中的闭包不在有问题
    * 防止重复声明变量
    * 防止变量未声明就使用
2. Array.from() 将伪数组对象或可遍历对象转换成真正的数组（伪数组就是一个对象键名是正整数或0，并且具有length属性）
    * Array.from()可以传入三个参数，第一个参数是必选的， 就是要被转化成真正数组的类数组结构，第二个参数是一个类似于map的函数，用于对传入
        伪数组对象的每个元素进行处理，然后将处理后的元素放入新数组，第三个参数，绑定map中用到的this
3. Aarray.of() 将传入的参数（不论是一个数还是多个数）转成数组中的成员，解决了new Array(3)传入一个参数，改变的是数组的length属性的问题
4. 数组的includes 方法判断数组中是否包含某个值， 和indexOf()相比，indexOf不够语义化，还需要和-1进行比较， indexOf 使用的===严格相等运算符
    ，这样在判断NaN时，会出现错误， 但是includes()在判断NaN时不会出现错误
5. 箭头函数 
    * 缩减代码，改变this指针，
    * 使用注意事项：
    * 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
    * 箭头函数不可以当作构造函数来使用，不可以使用new命令，否则会抛出错误
    * 不可以使用arguments对象，箭头函数没有arguments对象，可以使用rest参数代替
    * 不能使用yield 命令，所以箭头函数不能用作Generator函数
6. rest参数
    * 每个函数最多只能声明一个rest参数，而且rest参数必须是最后一个参数，否则报错
    * rest 参数不能用于对象字面量setter 中
7. 展开运算符（扩展运算符）
    * 展开运算符可以理解为是rest参数的逆运算，但是展开运算符的位置是随意的，用于将字符串和数组进行拆解
8. iterator 
    * 任何数据结构，只要部署了iterator接口，就可以完成遍历操作
    * 原生具备iterator接口的数据结构（可用for of 遍历）Array string set map 函数的arguments对象 NodeList对象
    * 几种遍历方式比较：
    * for of 循环不仅支持数组，大多数伪数组对象，也支持字符串遍历，此外还支持对set map 结构的遍历
    * for in 可以遍历字符串，对象，数组，不能遍历set map
    * forEach 不能遍历字符串和对象，可以遍历数组，伪数组，set map
    * 迭代器的工作原理：
    * 创建一个指针对象，指向数据结构的起始位置
    * 第一次调用next 方法的时候，指针自动指向数据结构的第一个成员
    * 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员
    * 每次调用next 方法返回的是一个包含  value和done 属性的对象，value 表示当前成员的值，done 表示当前的数据结构遍历是否结束
## TCP 和UDP
1. osi 七层网络模型
    * 物理层 ：以二进制数据形式在物理媒体上传输数据 
    * 数据链路层 ：传输有地址的帧以及错误检测功能
    * 网络层 ： 为数据包选择路由
    * 传输层： 建立管理和维护端到端的连接
    * 会话层 : 解除或建立与别的接点的联系
    * 表示层 ： 数据格式转化，数据加密
    * 应用层 ： 为应用程序提供服务，文件传输，文件服务，电子邮件等
2. UDP 用户数据报协议
    * 面向无连接 UDP不像TCP协议，在传输数据之前需要进行三次握手，UDP是直接发送数据，并且不会对数据进行任何拆分和拼接；
    * 有单播，多播，广播的功能 UDP支持一对一传输，一对多传输，多对一传输，多对多传输；
    * UDP 是面向报文的 UDP 不对要发送的报文进行拆分和合并处理，而是会保留报文边界，，因此应用程序必须选择合适大小的报文
    * 不可靠性 因为UDP 是面向无连接的，想发就发，所以不可靠，不会备份发送的数据，并且不关心对方是否正确接收到了完整的数据，UDP
        没有拥塞限制，网络差时，传输的速率还是一样快，不会变慢，这样就会导致丢包。
    * 头部信息少，开销小，传输数据报文很高效
    * UDP 的应用场景： 电话会议，视频会议，网络直播
3. TCP 传输控制协议
    * TCP 三次握手
        * 第一次 客户端向服务端发送连接请求报文段，该报文段包括自身的数据通讯初始序号，请求发送后，客户端便进入SYN-SENT状态 (syn 是同步序列号)
        * 第二次 服务端接收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始讯号，发送完后，服务端进入
            SYN-RECEIVED状态
        * 第三次 客户端接收到连接同意的应答后，还要向服务端发送一个确认报文，客户端发完确认报文后，进入ESTABLISHED状态，服务端接收到这个确认报文段
            后也进入ESTABLISHED状态，此时连接建立成功
    * TCP断开连接 四次挥手
        * 第一次挥手 客户端的请求发送完毕，则客户端向服务端发送连接释放请求；
        * 第二次挥手 服务端收到连接释放请求后，告诉应用层释放TCP连接，此时客户端到服务端的连接已经释放，不再接收客户端发的数据，因为TCP是双向的，
            所以服务端仍旧可以发数据给客户端
        * 第三次挥手 服务端此时如果还有没发送完的数据，会继续发送数据，发送完毕后，向客户端发送连接释放请求；
        * 第四次挥手 客户端收到释放连接请求后，向服务端发送确认应答，此时客户端进入time-wait状态，此状态会持续2MSL(如果报文段在网络中呆的时间超过2MSL就会被抛弃)
            若该时间段内，没有服务端的重发请求，客户端就进入CLOSED状态，服务端接收到确认应答后，也进如CLOSED状态
    * TCP协议的特点
        * 面向连接 在发送请求之前必须在客户端和服务端建立连接
        * 仅支持单播传输 每条TCP连接只能有两个端点，只能进行点对点的数据传输
        * 面向字节流 在不保留报文边界的情况下以字节流进行传输
        * 传输具有可靠性 
        * 提供拥塞控制 当网络出现拥塞的时候，TCP能够减小往网络注入数据的数量和速度，缓解拥塞
        * TCP提供双全工通信，服务端可以向客户端发送数据，客户端也能向服务端发送数据
        
## 如何清除浮动
1. 给浮动元素的父元素添加高度（扩展性不好）
2. 在父元素的末尾添加一个空div ， 设置这个div 的clear:both;
3. 给父元素的atfer 伪元素设置clear:both;
4. 触发父元素的BFC特性，因为BFC特性的元素可以包括浮动的元素
5. 添加一个br 标签，将br标签的clear 属性设置为all
## less 即学即用
1. less 基础语法分为以下几个方面
    * 变量
        * 和js中的变量一样，只是less中的变量用@声明
        * 变量不仅可以存储共用的属性值，还可以存储共用的URL，选择器，属性名等
    * 混合（Mixins）
        * 直接再另一个选择器中使用另一个类名，这样是会把代码复制一遍
        * 使用extend伪类, &:extend(.类名) 这样书写不会把代码复制一遍， 而是再原来的代码的选择器基础上，添加逗号以及新的类名
    * 嵌套规则  使用& 来找自己的父元素， sass 使用#来找自己的父元素
    * 函数和运算
        * 任何数字、颜色或是变量都可以参加运算
        * 提供了一系列颜色运算函数，颜色先被转换为hsl，然后再通道级别操作， 比如 lighten() darken()
        * 提供了一系列处理数字的函数，比如round() ceil() floor()
    *  命名空间和作用域
        * 会先在本地查找变量或者混合模块，如果没找到的话就会去父级作用域查找
## 关于响应式布局，你需要知道这些
1. 流式布局
    * 百分比布局也叫流式布局，百分比能够设置的属性是 width height padding margin 
    * 如果用百分比写width ,那么是指父元素内容宽度的百分比
    * 如果用百分比写height ,那么是指父元素内容高度的百分比
    * 如果用百分比写padding ,那么是指父元素内容宽度的百分比
    * 如果用百分比写margin ,那么是指父元素内容宽度的百分比
2. 媒体查询
    * IE6 7 8不支持媒体查询
    * 媒体查询就是根据不同视口宽度设置不同的样式，以实现自适应
    * @media screen and (min-width:600px) and (max-width:1200px){body:{background:blue}}
3. rem响应式布局
    * rem:当前页面中元素的REM单位的样式值都是针对HTML元素的font-size的值进行动态计算的
    * em：表示父元素字号的倍数（特例：在text-indent属性中，表示文字宽度）em不仅可以设置字号，还可以设置任何盒模型的属性
## 深入理解https的工作原理
1. http 与https 的区别
    * http 是明文传输协议，https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
    * https比http更加安全，对搜索引擎更加友好，利于SEO，谷歌百度优先索引https网页
    * https需要用到ssl证书，而http不用
    * https 端口号为443，http 的端口号为80
    * https 基于传输层，http 基于应用层
2. https 如何对数据进行加密
    * 对称加密
        客户端和服务端各有一份公钥，客户端用公钥对数据加密，服务端用公钥对数据解密；如果公钥被劫持，就可以解密得到数据
    * 非对称加密
        客户端有公钥，服务端有公钥和私钥，客户端用公钥对数据进行加密，服务端用公钥对应的私钥解密；效率比较低，公钥可能被篡改（中间人）
    * 对称加密+非对称加密（https采用这种方式）
        客户端和服务端通信之初，采用非对称加密的方式传输出用于加密解密数据的公钥，确认双方身份安全之后，采用对称加密传输数据
3. 使用数字签名解决传输的报文可能遭到篡改的问题
4. 使用数字证书解决通信方身份可能被伪装的问题
## 页面性能优化有哪些方法
1. 资源合并与压缩
    * 压缩html css js 合并css js 文件, 多个小图片可以组合成精灵图，减少网站http请求的次数
2. 非核心代码异步加载
    * 异步加载的三个方式:defer async 和动态创建script
    * 动态创建script 是在页面的onload事件触发时，创建script标签，并赋予src属性（这是在defer和async属性没有之前使用的方法）
3. 利用浏览器缓存
    * 强缓存和协商缓存
4. 使用CDN（content delivery network 内容分发网络）
    * 浏览器缓存只是提高了第二次访问网页的速度，首次访问的速度并没有得到优化
    * 将静态资源（css,js,图片等）缓存到离用户很近的相同网络运营商的CDN节点上，能提升用户的访问速度，还能节省服务器的带宽消耗
    * 一个地区内只要有一个用户先加载了资源，在CDN中建立了缓存，那么该地区的后续用户的访问速度都会得到提升
5. DNS预解析
    * 通过DNS预解析告诉浏览器未来可能会使用到哪些资源，当我们真正去使用这些资源的时候，就不需要再等待DNS解析的过程，从而节省了时间
    * 通过将link标签的 rel属性设置为 dns-prefetch 即可开启DNS预解析
    * 浏览器会对a标签中的href 自动启用DNS预解析，但是再https 中不起作用，需要通过meta 强制开启预解析功能
    * /meta http-equiv="x-dns-prefetch-control" content="on"/
6. 图片懒加载，减少cookie的大小，减少重排和重绘
## 图片懒加载实现思路
1. 懒加载用于页面中图片特别多，并且页面很长的场景
2. 将图片的src属性设置为空，将src 的真实值保存再另一个属性中，通过scroll事件判断页面的可视区域和图片相对于浏览器的视窗的位置，来
    确定图片加不加载，如果需要加载那么就将src的值赋给src属性
3. getBoundingClientRect()获取元素相对于浏览器视窗的位置
## 函数的节流和防抖
1. 节流（throttle）
    * 函数执行一次后，只有大于设定的执行周期后才会执行第二次
    * 节流的应用场景 DOM元素的拖拽功能，搜索联想，计算鼠标移动的距离，页面滚动事件
2. 防抖（debounce）
    * 一个频繁触发的函数，在规定的事件内，只让最后一次生效，前面的不生效
    * 防抖应用场景 文本输入的验证（多次触发只发送一次ajax）
3. 防抖和节流的实现都应用到了闭包
## 什么是函数式编程
1.  函数式编程的核心思想是通过函数对数据进行转换，函数式编程的两个特点:
    * 通过函数对数据进行转换
    * 通过串联多个函数来求结果
2. 函数式编程的常见特性：
    * 无副作用，调用函数不会修改外部状态，一个函数调用n次依然返回相同的结果
    * 透明引用，指一个函数只会用到传递给它的变量以及自己内部创建的变量，不会使用其他变量
    * 不可变变量，指的是一个变量一旦被创建后，就不能在被修改，任何修改都会生成一个新的变量，使用不可变变量的好处是线程安全
    * 函数是一等公民
3. 常见的函数式编程模型
    * 闭包
    * 高阶函数 高阶函数指的是一个函数的参数函数，或者返回值是函数，或者参数和返回值都是函数 数组Array的map filter reduce 方法
        都是高阶函数，他们的参数是一个函数
    * 函数柯里化 函数柯里化也叫部分求值，柯里化函数会接受一些参数，但是不会立即求值，而是返回一个新函数，将传入的参数以闭包的形式
        保存起来，等到求值的时候，一次性把所有的参数传入求值
    * 函数组合  传入多个函数类型的参数，然后调用， 避免多次串联调用带来的混乱
## css的100%, 是相对于其父元素的内容宽高的百分比,不包括边框和内边距 
1. 行内元素设置为浮动之后，其display 属性自动变为block ,如果你人为主动的设置display 不会生效
2. 如果像实现一个图片自适应，可以设置图片的max-width:100% 而不是width:100%， max-width表示图片最大就是图片自身的大小
    但是width 100% 不是这样，他会根据容器的变大而变大，会被拉伸
3. setTimeout和setInterval 的第三个以及以后的参数，会被当做回调函数的参数进行使用
4. 当给文档中的一个node节点指定一个新的父节点， 那么这个节点会在原来的位置消失，一个节点只能有一个父节点
## 如何加快首屏渲染的速度
1. js优化 将js文件放在body标签的底部，或者使用defer/async属性
2. css优化 <link> 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,
    最优的配置加载顺序，提高渲染性能
3. 使用localstorage 缓存一些内容稳定的文件或图片
## 前端SEO
1. TDK优化
    * 给网页设置title desciption keywords ,title强调重点即可，不同页面的title不要设置相同的内容，description 由于title的字数有限，
        可以用description添加对网页的描述，用自然语言描述页面的主要内容，最好每个关键词都覆盖一遍，keywords 关键词，三到五个关键词最佳
        关键词之间用英文逗号隔开， 提升页面中关键词的密度
2. 给非装饰性的图片设置alt 属性，爬虫会根据这个属性判断图片的内容 ，如果a标签是链接到外部网站的，那么需要给a标签设置el=nofollow 属性，
    这样爬虫就不会爬取外部链接里面的内容，因为一旦爬虫爬取外部链接，那么爬虫就不会再回到我们自己的网站
3. 少用iframe ，爬虫不会抓取iframe中的内容
4. 提高网站的的速度，网站的速度是搜索引擎排序的一个重要指标
5. 使用语义化标签，并且重要的内容放在页面的前面，因为爬虫抓取页面内容有长度限制
6. 导航优化，URL层级不要嵌套太深，不要超过四级，增加面包屑导航， 如果后期url要更换，可以向搜索引擎投诉或采取301永久重定向的方式跳转
7. 生成针对搜索引擎友好的网站地图 sitemap， 主动将网页提交给百度的接口，直接告诉告诉搜索引擎我们有哪些页面，通过在页面安装百度给的代码
    实时提交页面，当有用户访问网页的时候，这个页面就会实时提交给百度
8. 前后端分离，只关注数据， 如何实现SEO
    * 服务端渲染（ssr）将组件渲染为服务端的html代码，将他们发送到浏览器，前端只负责将html展示，利于SEO,前端耗时少，但是网络传输数据量
        大，服务端渲染框架Nuxt.js
    * 页面预渲染 （prerender）prerender 需要路由使用history 模式，使用hash模式会失效，预渲染的本质就是在项目打包的时候通过插件提前将
        js代码执行一遍，然后再将有内容的html放到服务器上，这样爬虫自然就可以抓取内容，解决了SEO的问题
    
    
## 从头开始学习Vuex
1. vuex简单来说就是对应用中多个组件的共享状态进行集中式管理（读/写）
2. 简单介绍vuex各模块在vuex执行流程中的作用
    * dispatch: 操作行为触发的方法，是唯一可以执行action的方法
    * actions：actions中的方法调用commit调用mutation中的方法，间接更改state中数据的状态；支持多个同名方法，按照注册顺序一次执行
    * commit: 是唯一能执行mutation的方法，然后更新state中数据的状态
    * mutations: 是唯一能改变state中数据状态的方法，同步更新
    * state： 存储共享状态变量的容器
    * getter： state对象的读取方法，可以将读取到的数据进行一层封装在返回给调用的组件
3. 改变state中数据状态的唯一方法就是显式提交commit(mutation)
4. actions和mutations功能基本一样，只是mutations是同步改变state的状态，actions 是异步改变state的状态
## 深入浅出响应式原理（数据绑定）
1. 总体思路
    * 遍历data对象，通过defineProperty()方法给所有属性加上get set 方法，从而可以监听到data对象所有属性的访问和修改，然后收集所有
        用到data对象中属性的地方，比如插值表达式，一般指令，事件指令等，并将属性和这些用到该属性的地方对应起来，当data对象中的属性发生了
        更改，就会触发属性的set方法，在set方法里面通知所有的与该属性相关的表达式或者指令，然后将新值更新到页面上。
2. 详细步骤
    * 通过defineProperty()方法给所有data对象的属性添加set和get 方法，并且为每一个属性建立一个Dep对象，这个Dep对象里面存放的是使用了该属性的
        所有地方（相当于订阅者，订阅了该属性的人），当以后属性发生改变的时候，Dep通知所有的订阅者，使用新的属性值更新页面。
    * 什么时候将订阅者添加到对应的Dep实体中呢，在页面解析的时候，也叫做模板编译的过程，模板编译的过程中，会遍历el容器中的所有子节点以及节点的
        属性，插值表达式，一般指令和事件命令就相当于订阅者，订阅不同的属性，在处理插值表达式以及一般指令和事件命令的时候，就会根据表达式在data
        中获取对应属性的值，此时就会触发属性的get 方法，这时就将订阅者添加到Dep的一个数组中，当data中某个属性的值发生了改变，那就让这个属性对应的
        Dep通知所有的订阅者，将新的属性值更新到页面上。
3. 双向数据绑定
    * 双向数据绑定是建立在数据绑定的基础上，数据绑定实现的是model到view的更新，双向数据绑定实现的是view到data到view的更新，利用了input 的
        oninput 事件以及一些元素的onchange事件；通过这些事件监控页面上数据的变化，将变化更新到data对象，然后根据数据绑定，再将新的数据更新到
        页面的订阅者身上
4. 问题
    * 无法检测到对象属性的添加和删除，添加属性可以使用Vue.set(obj,name,value)向嵌套对象添加响应式属性，删除属性可以用vm.$delete解决
    * 不能监听数组的变化，需要进行数组方法的重写，重写之后的方法需要能够被拦截，这样就可以获取数组的变化了
## 计算属性computed和监听属性watch
1. 监听属性适合用于观测某个值的变化然后去完成一系列复杂的业务逻辑，计算属性适合用在模板渲染，某个值依赖了其他的响应式对象甚至是计算属性
    计算得来的
2. computed 能做的watch 都能做，反之则不行，watch 可以观测路由地址的改变
3. computed计算出来的值会被缓存，这个计算属性依赖的响应式对象的值不变，则下次使用计算属性时，直接使用缓存，methods不能缓存
4. watch 具有深度遍历和立即调用的功能
    * watch 检测数据变化除了有回调函数，还有两个参数，deep和immediate， deep设置为true,用于监听对象内部值的变化，immediate设置为true，
        代表将以表达式当前的值触发回调
5. 计算属性不能执行异步任务，计算属性必须同步执行，计算属性不能向服务器请求或执行异步任务，而watch可以
## vue 中的虚拟DOM
1. 虚拟DOM可以理解为一个简单的JS对象，并且最少包含标签名tag，属性attrs，子元素对象children
2. 虚拟DOM在vue.js中做了两件事情：
    * 提供与真实DOM节点对应的虚拟节点vnode
    * 将新虚拟节点与旧虚拟节点进行对比，然后更新视图
3. 虚拟DOM的优势
    * 具备跨平台的优势，因为虚拟DOM是js 对象，不依赖真实的平台环境，所以在跨平台方面具有优势
    * 操作dom速度慢，但是js 运行的速率很快，所以可以将dom的对比操作放在js 层，来提高效率
    * 虚拟dom的优势不在于单次操作，而是大量的、频繁的数据更新时，能够对视图进行合理、高效的更新
4. diff算法，只比较同级的节点，同级的节点相同的话，就比较他们的子节点，如果不同，就替换，如果相同继续比较，是一个深度遍历的过程
## vue实例的生命周期
1. vue实例的生命周期共包含8个生命周期函数
    * beforeCreate 在beforeCreate生命周期函数执行的时候，vue实例上的data 和methods还没有初始化
    * created created生命周期函数执行的时候，data和methods都以及初始化好了，要调用methods上的方法和使用data上的数据最早在created生命周期函数
    * beforeMount beforeMount生命周期函数执行的时候，模板已经在内存中编译好了，但是尚未挂在到页面中去，此时页面还是旧的
    * mounted mounted生命周期函数执行的时候，内存中编译好的模板已经真实挂载到页面中去了， 如果要操作dom元素最早在mounted生命周期函数
        执行的时候，这时页面已经渲染好了，Vue实例初始化完毕，组件脱离了创建阶段，进入到运行阶段
    * beforeUpdate beforeUpdate生命周期函数执行的时候，页面中显示的数据还是旧的，但是vue实例中的数据已经时最新的了，但是页面尚未和data同步
    * updated updated生命周期函数执行的时候，根据最新的数据在内存中渲染一份DOM树，然后将最新的DOM渲染到页面中去，此时页面和数据同步
    * beforeDestory beforeDestory生命周期函数执行的时候，vue实例从运行阶段进入到销毁阶段，此时vm实例上的data methods 过滤器指令等都可以
        使用，还没有进入真正的销毁过程
    * destoryed destoryed生命周期函数执行的时候，组件已经完全被销毁，data methods等全部不可用
2. 在哪个阶段发送请求去获取数据
    * 如果异步获取的数据，需要对dom进行操作， 那就在mounted生命周期函数中请求
    * 如果不对dom进行操作，则可以在created生命周期函数中进行数据请求，因为数据请求是异步的，会受到网络等因素的影响，所以越早越好，并且此时vue
        实例已经初始化了data 和methods ,可以将请求到的数据保存到data对象上，或者调用methods中的方法对数据进行处理
3. vue实例的销毁阶段用来做善后工作，比如清理定时器，删除第三方实例
    * 对比： 内部销毁 vs 外部销毁
      外部销毁不仅能销毁组件，也能销毁该组件的dom结构
      内部销毁只能销毁组件，不能销毁组件的dom结构
## 组件之间传值
1. 父子组件通讯
    * 父组件向子组件传值，通过props+属性绑定；子组件向父组件传值，绑定方法+this.$emit(funcNmae,para)；
    * 通过给子组件添加ref属性，这样就可以访问子组件中的数据和方法；
    * 祖先组件使用provide提供一个属性，后代组件使用inject注入这个属性，然后子组件就可以使用这个属性了
2. 兄弟组件之间传值
    * 使用Vuex 实现兄弟组件之间传值
    * 使用中央事件总线实现兄弟组件之间传值，创建一个空的vue实例，vue.$on()得到值，vue.$emit()传值
3. 跨级通讯
    * 祖先组件使用provide提供一个属性，后代组件使用inject注入这个属性，然后子组件就可以使用这个属性了
    * 中央事件总线
    * Vuex
## 前端模块化详解
1. CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此
    有了AMD CMD解决方案，node采用的commonjs规范
2. AMD规范在浏览器环境中可以异步加载，而且可以并行加载多个模块，不过AMD规范开发成本高，代码阅读和书写比较困难
3. CMD与AMD规范类似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在node.js中运行，不过依赖spm打包，模块的加载逻辑偏重
4. ES6在语言标准的层面上，实现了模块功能，而且实现的很简单， 完全可以取代commonjs和AMD规范，成为浏览器和服务器通用
    的模块解决方案
## 九大排序算法
1. 冒泡排序
    * 每个元素和他的下一个元素比较，如果大于下一个元素，就将这两个元素交换位置，一轮交换完成后，数组中最大的元素排在的了最后，
        第二轮交换完后，数组中第二大的元素排在了倒数第二位，如此往复，经过数组长度次交换，就完成了排序，算法复杂度O（n^2）
2. 选择排序
    * 整体思想：选择出数组中的最大或最小的元素，这里以最小的元素为例介绍，第一次找出数组中最小的元素，放在数组的最前面，然后再
        数组剩下的元素中找出最小的元素，放在刚才最小元素的后面，如此往复，就完成了排序，算法复杂度O（n^2）
3. 插入排序
    * 从数组第一个元素开始，比较第二个元素和第一个元素的大小，如果比第一个元素大就放在第一个元素的后面，如果比第一个元素小就放在第一个
        元素的前面，然后再拿第三个元素和前两个元素比较,比较的时候是从后往前面比较，将第三个元素放到合适的位置，如此往复，就完成了排序，算法复杂度O（n^2）
4. 快速排序（二分）
    * 从数组中选择一个基数，将比这个基数小的数放到一个数组中，将比这个基数大的数放到另一个数组中，然后通过递归，对这两个数组继续进行二分，
        直到数组中只剩一个元素，就将所有这些数组利用concat方法组合起来，就完成了排序，时间复杂度O（nlog2n）
5. 希尔排序
    * 希尔排序是对插入排序的改进，插入排序对小规模数据以及初始时的数字序列比较好的数据进行排序时效率特别高，但是当插入排序处理大量数据的时候
        效率就会和很低下，那么希尔排序时怎么对插入排序进行改进的呢？ 设置一个增量，根据这个增量，将数据分成若干组，然后对这若干组数据进行
        插入排序，然后再将这个增量/2，或者变得更小，根据新增量，将数组分成若干组，在对这些若干组进行插入排序，如此往复，直到增量变为1，直接
        对这个已经差不多排好序的数组进行插入排序，得到最终的排好序的数组
6. 堆排序
    * 将数组中的元素转换成大顶堆，此时根节点为最大值，然后将根节点与最后一个节点交换，除去最后一个节点，再将其余节点转换成大顶堆，如此往复
        就依次得到了最大值，次最大值，。。。， 最后实现了数组的排序
7. 计数排序
    * 不是通过比较元素，而是记录每个元素出现的个数，可以利用一个对象（不能用对象就利用数组的索引），元素是多少就添加一个对应的属性，然后
        遍历对象，判断属性值，如果是一个就输出一个，如果是多个就输出多个，然后就得到排序好的数组了
8. 桶排序
    * 首先确定桶的个数，不能大于数组的长度，然后数组的长度/桶数，就是每个桶要放多少个元素，容量，然后遍历数组中的每个元素，（元素-数组中的最小值）/容量
        得到的就是这个元素要放在第几个索引的桶中，每个桶中可能需要多个元素，再放入多个元素的时候，需要使用插入排序，直接将桶中的元素的顺序
        排好；如此往复，就将所有的数组放在了所有桶中，在按索引将桶中的元素整合到一个数组中，就完成了排序
9. 基数排序
    * 设置一个基数0-9， 先按照个位将数组中的元素分别分到对应的数字中，然后按0-9的顺序取出元素放到新数组，再按照十位的数字分别分到对应的
        数字中，如果没有十位就放到0中，如此往复，就是实现了数组中元素的排序
## async和defer的特性和区别
1. 具有async属性的外部脚本会异步加载，一旦加载完立即执行；
2. 具有defer属性的外部脚本会异步加载,等文档加载解析完在执行；
3. 如果有多个具有defer属性的外部脚本，加载完后会按顺序执行；
4. 如果有多个具有async属性的外部脚本，脚本的执行顺序不确定；
5. defer的脚本在domcontentloaded 和 load 事件执行前执行，async的脚本在load事件之前执行，和
	domcontentloaded的执行顺序不确定；
	
## requestAnimationFrame的使用
1. 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，
	不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔
	是1000ms/60，约等于16.6ms;
2. 而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际
	上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，
	那动画代码就要等前面的任务完成后再执行;
3. requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，
	增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，
	从而节省系统资源，提高系统性能，改善视觉效果;
4. requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，
	并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率;
5. 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，
	这当然就意味着更少的CPU、GPU和内存使用量;
6. requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，
	并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销;
7. 当我们写window.requestAnimationFrame(回调函数)时，浏览器会在下次重绘前执行回调函数;
## Vue 父子组件传值以及非父子组件传值
1. 父组件向子组件传值,父组件中通过属性绑定，绑定一个要传送的值，子组件在props中定义一个同名变量
	然后就可以通过this.变量名来使用这个父组件中的值了
2. 子组件向父组件传值，父组件通过v-on事件绑定，向子组件传递一个函数（有形参）， 子组件中通过this.$emit("函数名"，传递的值)
	父组件可以通过形参拿到子组件传递过来的值
3. 子组件向父组件传值，可以在父组件通过属性绑定的方式，向子组件传递一个引用类型的值，这样子组件更改引用
	类型的值，父组件中的值就会进行相应的改变，因为传递的是变量的引用地址
4. 非父子组件之间进行值的传递（中央事件总线）， 定义一个空的vue示例 bus，在组件A中通过bus.$emit("funcName",传递的值)来传递值
	在组件B中通过bus.$on("funcName",(param)=>{param})来得到A组件传递过来的值，记得使用bus.$off()销毁监听
5. 通过Vuex来实现组件之间值的传递
## 如何设计一个组件，设计一个组件要考虑的问题
1. 这个组件可否应用于其他类似场景
2. 这个组件是否对其他组件造成了入侵，一个组件不应对他的兄弟组件造成直接影响
3. 这个组件有没有必要在细分

## 基础知识汇总
1. 盒模型
    * dom.offsetWidth 获取的是content+padding+border 的总宽度，当设置为content-box时,offsetWidth 为设置的宽+内边距+边框
        当设置为border-box的时候，offsetWidth 为 设置的宽（因为padding和border把内容挤小了，但是总的盒模型大小没变） 不带单位
    * dom.getBoundingClientRect().width/height 获取盒模型的宽高(content+padding+border)  不带单位
    * window.getComputedStyle(dom).width/height 获取的就是你设置的宽和高，并且带px单位 ， 不是content+padding+border
    * dom.currentStyle.width/height IE中特有的，获取你设置的dom元素的宽和高
    * dom.style.width/height 只能获取行内样式里面设置的宽和高，并且带单位，不是content+padding+border
    * 标准盒模型的宽为content的宽，IE盒模型的宽为content+padding+border的宽，css3的box-sizing属性 content-box 为标准盒模型
        border-box 为IE盒模型
2. 兄弟盒子外边距重叠问题
    * 如果上下外边距都为正数的话，取值大的那个
    * 如果上下外边距都为负数的话，取绝对值大的那个
    * 如果上下外边距一正一负的话，那两个值求和就是真实的外边距
    * 如何解决外边距重叠问题：使两个盒子属于不同的BFC
3. 伪类和伪元素的了解
    * css3中规定，伪元素用双冒号，伪类用单冒号，在css3之前伪类和伪元素都是用单冒号表示
    * 伪类分为两种，一种是状态伪类，一种是结构为类，状态伪类是基于元素当前状态进行选择的，当元素进入某个状态，显示什么样的样式，当元素
        离开这个状态，样式就会切换，常见的状态伪类有 link,visited hover active focus; 结构伪类是css3新增的选择器，通过文档结构的互相关系
        来匹配元素，可以减少文档中class 和id 属性的定义，可以获取到那些用普通css选择器不好获取的元素，并给其设置样式，常见的结构伪类有
        first-child last-child nth-child() first-of-type last-of-type等
    * 伪元素 伪元素是对元素中的特定内容进行操作，选择元素内容的最前面或者最后面这种普通选择器无法选择到的区域，控制的内容和元素是相同的，
        它本身是基于元素的抽象， 并不存在于文档结构中，常见的伪元素有： after before first-letter first-line
    * 伪元素的应用
        * 清除浮动
        * 增大点击的区域
        * 通过伪元素设置小图标
        * 画分割线
4. ES6新属性都用过哪些？
    * let const 箭头函数，数组的一些方法，map filter find forEach 等，模板字符串，扩展运算符，剩余参数，函数参数的默认值  class
    
5. 原生的ajax自带超时机制，XMLHttpRequest.timeout , 设置timeout 属性， 来实现ajax请求多久会超时，通过xhr.ontimeout 事件处理请求超时后的操作
    同步的ajax 不能使用timeout属性， 默认值为0，意味着没有超时；
    jsonp 没有自带的超时机制,jsonp 如果在设定的时间内没有返回响应， 那么就将这个发起jsonp的script标签在文档中移除 removeChild()
6. fetch 是替代XMLHTTPRequest 请求数据的一种方式， fetch 方法是基于promise 标准实现的，支持async/await ,fetch方法接收两个参数，第一个是url
    要请求的资源的地址，第二个参数是一个配置对象，用来配置请求方法，头部信息，要传输的数据，是否支持跨域等信息， fetch 方法返回的是一个promise
    对象，所以可以调用then方法和catch方法做进一步的处理，请求成功，进入then方法，请求失败进入catch方法
    xhr 可以在open（）方法的第三个参数设置是异步请求还是同步请求，但是fetch 只支持异步请求，无法发送同步请求，并且fetch 也没有自带的超时机制
    可以自己通过settimeout 去封装一个超时功能
7. cookie 都有哪些属性
    * name 为cookie的名称， value 为cookie的值， domain 为可以访问此cookie的域名，path 可以访问此cookie的页面路径 expires 为cookie 的到期时间
        expires 现在已经被max-age 取代 size 为cookie 的大小，httponly 为 不允许js 获取cookie ，secure 只有https 协议的请求才能携带cookie ， 
        same-site 不允许跨域请求携带cookie， cookie 在http协议中是明文传递的，所以存在安全性问题，如果被别人截获，那么就能获取到用户的一些信息，
        可以使用MD5算法对cookie 进行加密， MD5加密后，是不可逆的， 所以需要在数据库中，存储一个对应的MD5的字段，用来做验证
8. http请求头 Cache-control connection date if-none-match if-modified-since referer cookie content-type
9. http响应头 Etag last-modified expires Cache-control connection content-type date  set-cookie x-frames-option
10. 滑动窗口，滑动窗口是一种流量控制技术，滑动窗口的大小意味着数据接收方还有多大的缓冲区可以用于接收数据，发送方可以根据滑动窗口的大小来确定应该
    发送多少字节的数据。 因为当网络差时，如果发送方向网络中注入数据的速度和数量还是一定的， 就会造成丢包的情况。
11. http3 的新特性
    * http3产生的一个重大原因就是，http2实现了多路复用，这样一般情况下只需要一个tcp连接就可以完成任务，但是当这个连接中出现了丢包的情况，整个tcp
        都要等待重传， 这样就导致了后面数据的阻塞，导致http2还不如http1.1的表现，http1.1可以开启多个tcp， 一个tcp丢包了，不会影响其他的tcp
        传输数据。 为了解决这个问题，http3就产生了，http3是基于quic协议的，quic协议是基于UDP协议的
    * 连接更快速和高效（0-RTT建立连接）
    * 虽然http2实现了多路复用，但是tcp协议终究是没有这个功能的，quic协议原生就实现了多路复用的功能
    * TCP协议的头部信息没有经过任何的加密和认证，而QUIC协议报文头部经过认证，报文主体经过加密，安全性更高
    * 向前纠错机制，每个数据包除了它本身的内容之外，还包括一点其他数据包的内容，所以少量的丢包可以通过其他包的冗余数据组装而无需重传，但是
        这种情况只适用于丢失一个包的情况，如果出现丢了多个包的情况，那么就需要进行重传
12. loader和plugin 的区别
    * loader可以将文件转换为webpack能处理的有效模块，然后利用webpack的打包能力，对他们进行处理
    * 插件用于执行广泛的任务，比如打包优化、压缩、重新定义环境中的变量等
    * 用过插件，js压缩插件  uglifyjs-webpack-plugin html打包插件html-webpack-plugin
    * 用过的loader 处理less 的loader 处理图片的loader  处理.vue文件的loader
13. css动画
    * transition 是一个简写属性， 用于设置四个过度属性
        * transition-property 
        * transition-duration
        * transition-timing-function
        * transition-delay
    * animation : name duration timing-function delay iteration-count direction fill-mode play-state
        * name 动画的名字
        * duration 动画持续的时间
        * timing-function 动画的速度设置 linear  ease ease-in ease-out ease-in-out 贝塞尔曲线
        * delay 动画在延迟多久后开始
        * iteration-count 动画执行的次数
        * direction 动画执行的方向 
        * fill-mode 动画在不执行的时候的样式（动画执行之前和动画执行之后） none backwards forwards both
        * play-state 动画的状态  paused running
    * transition和animation 的区别
        * transition 通常和hover等事件配合使用，由事件触发， animation 无需触发立即播放
        * animation 可以设定执行的次数， transition 需要由事件触发来执行
        * 精确性， animation 可以设置每一帧的样式和时间，transition 只能设置头尾
        * animation 与js的交互不是很紧密，transition 和js结合更加强大，js 设定要变化的样式，transition负责动画效果
14. webpack 优化
15. 为什么http2的多路复用可以传输多个请求
    * 首先分析http1.x中的问题，因为http1.x版本中，请求包括请求行、请求头、空行、请求体，服务端需要进行一行一行的解析，以换行为为界，
        必须连续解析，无法中断，所以就导致必须解析完一个请求，才能解析下一个请求。
    * http2 将请求和响应分割成更小的二进制帧，帧是http2.0 最小的通信单位，多个帧组成一个流，一个流相当于一个请求或响应， 每个帧包含他所属的
        流的唯一标志， 这样可以在请求发送完后，或响应完之后，重新进行组装。 也不会产生混乱。 所以http2的多路复用可以实现并行发送多个请求和响应
16. 如何实现函数重载（重写是重写父类的方法，重载是一个方法，不同的参数个数或类型，不同的表现）
    * 通过switch 判断 arguments.length的个数 ，通过不同的个数做不同的事情；
17. 函数柯里化详解
    * 函数柯里化简单来说就是将接受多个参数的函数变成接收一个单一参数的函数，并且返回一个接收余下参数并且计算结果的新函数。
    * 函数柯里化的用处：
        * 参数复用，可能我们实现一个功能需要传递两个参数，并且第一个参数是固定的，这样我们通过函数柯里化，重复利用第一个参数，就不需要每次
            都传入这个固定的参数了，只需要传入第二个变化的参数即可；
        * 提前确认，我们在给dom元素添加事件的时候，需要判断当前浏览器支持哪种添加事件监听的方式，然后使用当前浏览器支持的方式给dom元素添加事件
            ，这种判断兼容性的操作， 我们不想每次都做，所以可以通过函数柯里化（以立即执行函数的方式），提前确认当前浏览器支持的方式，以后再给dom
            元素添加事件，就直接使用立即执行函数返回的函数即可
        * 延迟执行，我们使用的bind 函数就是，实现的机制就是函数柯里化
18. promise 有哪些缺点
    * 无法取消promise ,一旦新建它就会立即执行，无法中途取消
    * 如果不设置回调函数，promise 内部抛出的错误不会反应到外部，外部无法得知
    * 当promise 处于pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
19. Generator 函数
    * 只有当调用next 方法，内部指针指向yield 表达式后， yield 表达式后面的语句才会被执行，相当于为javascript提供了惰性求值
    * 可以通过next 方法的参数，向正在执行的函数体内注入新值，以改变函数的行为
    * Generator 函数执行返回遍历器对象， 遍历器对象的三大api next ， throw ， return 
20. async 函数对generator 函数的改进主要体现在以下四点
    * async函数内置执行器，而generator函数的执行必须依靠执行器，所以才有了co模块
    * 更好的语义
    * 更广的适用性，co模块约定，yield 命令后面只能是Thunk函数或者是promise 对象， 而async函数后面既可以是promise对象，也可以是原始数据
        类型（原始数据类型会被立即包装成状态为reloved 的promise 对象）
    * 返回值是promise ，async 函数的返回值是promise对象， 你可以用then 方法指定下一步操作，async函数完全可以看作是多个异步操作包装成
        一个promise 对象 ， await 就相当于是then 方法的语法糖
21. proxy 用于修改某些操作的默认行为， reflect 是将object 对象上的一些方法添加到reflect对象上。 object 对象上的某些方法是命令式的，
    reflect 对象上的方法修改成了函数式的， reflect 上的方法和proxy 上的方法一致 
22. jquery 插件  jquery 几种事件代理的以及不同  写一个只能执行一次的函数 vue的数据绑定是异步的， 一次for循环找出数组中的第二大值  vue-router 的几种模式
    vue 为什么不能监听数组的数据的改变
        
